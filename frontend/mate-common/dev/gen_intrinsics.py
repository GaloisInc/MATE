#!/usr/bin/env python3

import sys
from itertools import dropwhile, takewhile
from os import chdir
from pathlib import Path
from subprocess import check_output


def eprint(msg: str, die: bool = True) -> None:
    print("ERROR:", msg)
    if die:
        sys.exit(1)


if __name__ != "__main__":
    eprint("This is a script")

parent = Path(__file__).resolve().parent
wedlock_dir = parent.parent.parent.parent / "submodules" / "llvm-wedlock"

if not wedlock_dir.exists():
    eprint(f"Couldn't find llvm-wedlock at {wedlock_dir}")

chdir(wedlock_dir / "llvm")
stdout = check_output(
    ["llvm-tblgen-10", "include/llvm/IR/Intrinsics.td", "--gen-intrinsic-impl", "-I", "include"]
)

# The 'next' is because the first line is a comment
out = takewhile(
    lambda line: line != "#endif",
    dropwhile(
        lambda line: line != "#ifdef GET_INTRINSIC_NAME_TABLE", stdout.decode("utf-8").splitlines()
    ),
)

HEAD = """
'''This file is generated by gen_intrinsics.py. DO NOT EDIT. '''
from enum import Enum, unique
@unique
class LLVMIntrinsic(Enum):
   '''
   Base names and IDs of LLVM intrinsics

   These are not the full function names: Some are overloaded, so callsites
   have type information in the name, separated by '.'.
   '''
"""

next(out)  # first line is a comment about index 0
next(out)  # ??? My mental model is apparently off-by-one...
with open(parent / "intrinsics.py", mode="w") as f:
    f.write(HEAD)
    for index, line in enumerate(out):
        llvm_name = line[3:-2]  # quotes, spaces, commas

        if any(
            llvm_name[5:].startswith(arch + ".")
            for arch in (
                "aarch64",
                "amdgcn",
                "arm",
                "hexagon",
                "mips",
                "nvvm",
                "ppc",
                "r600",
                "s390",
                "xcore",
            )
        ):
            continue

        python_name = llvm_name[len("llvm.") :].upper().replace(".", "_")
        f.write(f"   {python_name} = {index + 1}\n")
